#signal信号

## signal的基础概念
### signal是什么？

- 是软中断。
- 不同signal有不同的处理方式。



### signal有哪些？

信号 值 处理动作 发出信号的原因 
\---------------------------------------------------------------------- 
SIGHUP 1 A 终端挂起或者控制进程终止 
SIGINT 2 A 键盘中断（如break键被按下） 
SIGQUIT 3 C 键盘的退出键被按下 
SIGILL 4 C 非法指令 
SIGABRT 6 C 由abort(3)发出的退出指令 
SIGFPE 8 C 浮点异常 
SIGKILL 9 AEF Kill信号 
SIGSEGV 11 C 无效的内存引用 
SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道 
SIGALRM 14 A 由alarm(2)发出的信号 
SIGTERM 15 A 终止信号 
SIGUSR1 30,10,16 A 用户自定义信号1 
SIGUSR2 31,12,17 A 用户自定义信号2 
SIGCHLD 20,17,18 B 子进程结束信号  说明：子进程退出过程中，内核会给其父进程发送这个信号，通知它来“收尸”
SIGCONT 19,18,25 进程继续（曾被停止的进程）  说明：当进程进入可中断睡眠状态可由此状态恢复 
SIGSTOP 17,19,23 DEF 终止进程 
SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键 
SIGTTIN 21,21,26 D 后台进程企图从控制终端读 
SIGTTOU 22,22,27 D 后台进程企图从控制终端写 

注：大部分信号可被忽略，除SIGSTOP和SIGKILL信号外（这是超级用户杀掉或停掉任意进程的手段）。

## signal的基本流程

1. **用户态**发出signal
2. **内核态**检测到信号，去寻找信号处理函数。
3. **用户态**执行信号处理函数。
4. 执行完毕后返回**内核态**检查是否还有其他信号处理函数需要处理。

即： 发出信号与信号处理函数都在用户态定义。

### 发送信号

kill发送信号，并不会直接硬中断，而只是把信号挂载到目标进程的pending队列上。

### 处理信号

1. 只有在进程从内核态返回用户态前夕才会检测signal，若在内核态运行则软中断不会立即起作用。

``` c
el0_sync()/el0_irq() -> ret_to_user() -> work_pending() -> do_notify_resume()
```

